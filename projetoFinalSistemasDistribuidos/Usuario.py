import json
import logging
import threading
from datetime import datetime, timedelta
from queue import Queue

import zmq

import ReturnCodes


class User:
    """
    Representa um usuÃ¡rio da rede social distribuÃ­da.
    Gerencia conexÃµes, aÃ§Ãµes do usuÃ¡rio (seguir, postar, enviar mensagens privadas),
    e tratamento de notificaÃ§Ãµes em tempo real via PUB/SUB.
    """

    def __init__(self, username):
        """
        Inicializa um novo usuÃ¡rio, registra no sistema distribuÃ­do e inicia thread para notificaÃ§Ãµes.
        """
        self.username = username

        # CriaÃ§Ã£o dos sockets do usuÃ¡rio (REQ para comandos, SUB para notificaÃ§Ãµes)
        self.context = zmq.Context()
        self.reqSocket = self.context.socket(zmq.REQ)
        self.reqSocket.connect("tcp://localhost:5555")

        self.notificationSocket = self.context.socket(zmq.SUB)
        self.notificationSocket.connect("tcp://localhost:6010")

        self.followedUsers = list()  # Lista de usernames seguidos
        self.notificationQueue = Queue()  # Fila local de notificaÃ§Ãµes recebidas

        self.userId = 0  # SerÃ¡ atribuÃ­do apÃ³s cadastro
        self.notifyTopic = None  # TÃ³pico PUB/SUB usado para notificaÃ§Ãµes
        self.forcedDelay = 0  # Atraso artificial para simulaÃ§Ã£o de clocks defasados

        self.sign_up()
        self.start_threads()

    def sign_up(self):
        """
        Realiza o cadastro do usuÃ¡rio junto ao servidor.
        Em caso de conflito de username, solicita um novo.
        """
        while True:
            package = {
                "action": "add_user",
                "username": self.username
            }
            serialized_package = json.dumps(package).encode('utf-8')
            self.reqSocket.send(serialized_package)

            signupResponseBytes = self.reqSocket.recv().decode('utf-8')
            signupResponse = json.loads(signupResponseBytes)

            if signupResponse["ret"] == 0:
                # Cadastro bem-sucedido
                self.userId = signupResponse["id"]
                self.notifyTopic = signupResponse["topic"]
                self.notificationSocket.setsockopt_string(zmq.SUBSCRIBE, self.notifyTopic)
                print(
                    f"UsuÃ¡rio '{self.username}' cadastrado com sucesso com ID {self.userId} e tÃ³pico '{self.notifyTopic}'.")

                # Configura logging individual para este usuÃ¡rio
                logging.basicConfig(
                    filename=f'{self.username}.log',
                    level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s'
                )

                logging.info(
                    f"UsuÃ¡rio '{self.username}' cadastrado com sucesso. ID: {self.userId}, tÃ³pico: {self.notifyTopic}")
                break
            else:
                # Username jÃ¡ existe: forÃ§a o usuÃ¡rio a digitar outro
                print("Username invÃ¡lido - outro usuÃ¡rio jÃ¡ possui esse username!")
                self.username = input("Informe um novo username: ")

        return

    def wait_for_notify_message(self):
        """
        Thread responsÃ¡vel por receber mensagens do canal de notificaÃ§Ãµes
        (via PUB/SUB) e inserir na fila local para leitura posterior.
        """
        while True:
            try:
                message = self.notificationSocket.recv_string(flags=zmq.NOBLOCK)
                self.notificationQueue.put_nowait(message)
            except zmq.Again:
                continue

    def start_threads(self):
        """
        Inicializa a thread de escuta para notificaÃ§Ãµes (daemon).
        """
        notifyThread = threading.Thread(target=self.wait_for_notify_message, daemon=True)
        notifyThread.start()

    def follow(self, user):
        """
        (NÃ£o usado diretamente: placeholder para um possÃ­vel sistema mais complexo de seguimento local.)
        """
        self.followedUsers.append(user)

    def __str__(self):
        """
        Retorna representaÃ§Ã£o amigÃ¡vel do usuÃ¡rio.
        """
        return f"UsuÃ¡rio: {self.username}"

    def post_text(self):
        """
        Permite ao usuÃ¡rio publicar um texto na rede social.
        O timestamp pode ser atrasado artificialmente para testes de sincronizaÃ§Ã£o.
        """
        print("\n--- Publicar Texto ---")
        text = input("Digite seu texto: ")

        messageTimestamp = datetime.now() - timedelta(seconds=self.forcedDelay)

        messagePayload = {
            "action": "post_text",
            "username": self.username,
            "id": self.userId,
            "texto": text,
            "tempoEnvioMensagem": messageTimestamp.isoformat()
        }

        serializedMessage = json.dumps(messagePayload).encode('utf-8')

        self.reqSocket.send(serializedMessage)

        response = self.reqSocket.recv()
        logging.info(f"UsuÃ¡rio '{self.username}' publicou um texto: '{text}'")

    def view_timeline(self):
        """
        Solicita e exibe a timeline do usuÃ¡rio, mostrando todos os posts disponÃ­veis.
        """
        timelineRequestMessage = {
            "action": "get_timeline"
        }
        self.reqSocket.send(json.dumps(timelineRequestMessage).encode('utf-8'))

        print("Enviou mensagem de req")
        print("Esperando resposta")

        serializedPosts = self.reqSocket.recv()
        print("Recebeu postagens")

        posts = json.loads(serializedPosts.decode('utf-8'))

        logging.info(f"UsuÃ¡rio '{self.username}' visualizou a timeline")

        print("\n--- Postagens Recebidas ---")
        for post in posts:
            print("----------------------------------")
            print(f"User: {post['username']}")
            print(f"Texto: {post['texto']}")
            print(f"Enviado em: {post['tempoEnvioMensagem']}")

    def follow_user(self):
        """
        Permite ao usuÃ¡rio seguir outro usuÃ¡rio na rede.
        Trata validaÃ§Ã£o para nÃ£o seguir a si mesmo e reporta resultado.
        """
        print("\n--- Seguir UsuÃ¡rio ---")
        usernameInput = input("Digite o nome do usuÃ¡rio que deseja seguir: ")

        if usernameInput == self.username:
            print("VocÃª nÃ£o pode seguir a si mesmo.")
            logging.warning(f"UsuÃ¡rio '{self.username}' tentou seguir a si mesmo.")
            return

        followRequest = {
            "action": "add_follower",
            "id": self.userId,
            "to_follow": usernameInput
        }

        serializedMessage = json.dumps(followRequest).encode('utf-8')
        self.reqSocket.send(serializedMessage)

        responseBytes = self.reqSocket.recv()
        response = json.loads(responseBytes.decode('utf-8'))

        if response["ret"] == ReturnCodes.SUCCESS:
            print(f"Agora vocÃª estÃ¡ seguindo {usernameInput}.")
            logging.info(f"UsuÃ¡rio '{self.username}' seguiu o usuÃ¡rio '{usernameInput}'")
            self.followedUsers.append(usernameInput)
        elif response["ret"] == ReturnCodes.ERROR_USER_NOT_FOUND:
            print("UsuÃ¡rio nÃ£o encontrado.")
            logging.warning(f"UsuÃ¡rio '{usernameInput}' nÃ£o encontrado para seguir por '{self.username}'")
        elif response["ret"] == ReturnCodes.ERROR_INVALID_PARAMETER:
            logging.warning(f"UsuÃ¡rio '{usernameInput}' nÃ£o pode seguir a ele mesmo")
        else:
            print("Erro ao tentar seguir o usuÃ¡rio.")
            logging.error(f"Erro ao seguir usuÃ¡rio '{usernameInput}' por '{self.username}'")

    def display_conversation(self, sender, recipient):
        """
        Solicita e exibe toda a conversa privada entre o usuÃ¡rio atual e outro usuÃ¡rio.
        """
        requestPayload = {
            "action": "get_private_messages",
            "remetente": sender,
            "destinatario": recipient
        }

        serializedMessage = json.dumps(requestPayload).encode('utf-8')
        self.reqSocket.send(serializedMessage)

        serializedMessages = self.reqSocket.recv()
        response = json.loads(serializedMessages.decode('utf-8'))
        messages = response["mensagens"]

        print("\nðŸ“± Conversa entre vocÃª e", recipient)
        print("-" * 50)

        for item in messages:
            if len(item) == 3:
                message, ts, msgSender = item
            else:
                continue

            try:
                timeFormatted = datetime.fromtimestamp(int(ts)).strftime("%H:%M")
            except (ValueError, TypeError):
                timeFormatted = "??:??"

            # Alinhamento diferente para mensagens enviadas e recebidas
            if msgSender == self.username:
                print(f"{'':>25} {msgSender}: {message}  ðŸ•’{timeFormatted}")
            else:
                print(f"{msgSender}: {message}  ðŸ•’{timeFormatted}")

    def send_private_message(self):
        """
        Permite enviar uma mensagem privada para outro usuÃ¡rio.
        TambÃ©m exibe a conversa antes do envio para dar contexto ao usuÃ¡rio.
        """
        print("\n--- Enviar Mensagem Privada ---")
        sender = self.username
        recipient = input("Digite o nome do destinatÃ¡rio: ")

        if recipient == sender:
            print("VocÃª nÃ£o pode enviar mensagens para si mesmo.")
            logging.warning(f"UsuÃ¡rio '{sender}' tentou enviar mensagem para si mesmo.")
            return

        self.display_conversation(sender, recipient)

        message = input("Digite a mensagem: ")
        adjustedTime = datetime.now() - timedelta(seconds=self.forcedDelay)
        timestamp = str(int(adjustedTime.timestamp()))
        if self.forcedDelay > 0:
            logging.info(f"Atraso de {self.forcedDelay}s aplicado na mensagem privada.")

        messageRequest = {
            "action": "add_private_message",
            "remetente": sender,
            "destinatario": recipient,
            "mensagem": message,
            "timestamp": timestamp
        }

        serializedMessage = json.dumps(messageRequest).encode('utf-8')
        self.reqSocket.send(serializedMessage)

        responseBytes = self.reqSocket.recv()
        response = json.loads(responseBytes.decode('utf-8'))

        if response["ret"] == ReturnCodes.SUCCESS:
            logging.info(f"UsuÃ¡rio '{sender}' enviou mensagem para '{recipient}': '{message}'")
            self.display_conversation(sender, recipient)
        else:
            print("Erro ao enviar mensagem, tente novamente!")
            logging.error(f"Erro ao enviar mensagem de '{sender}' para '{recipient}'")

    def view_notifications(self):
        """
        Exibe todas as notificaÃ§Ãµes recebidas via PUB/SUB que ainda nÃ£o foram lidas.
        """
        print("\n--- Ver NotificaÃ§Ãµes ---")

        notifications = []
        while not self.notificationQueue.empty():
            notification = self.notificationQueue.get_nowait()
            notifications.append(notification)

        logging.info(f"UsuÃ¡rio '{self.username}' verificou notificaÃ§Ãµes. Total: {len(notifications)}")

        if not notifications:
            print("Nenhuma nova notificaÃ§Ã£o.")
        else:
            for idx, notification in enumerate(notifications, 1):
                print(f"[{idx}] {notification}")

    def set_forced_delay(self):
        """
        Permite ao usuÃ¡rio definir um atraso artificial no relÃ³gio local,
        simulando clocks defasados em ambiente distribuÃ­do.
        """
        print("\n--- Configurar Atraso ForÃ§ado ---")
        try:
            delay = int(input("Digite o atraso em segundos (0 para nenhum): "))
            self.forcedDelay = delay
            print(f"Atraso forÃ§ado configurado para {delay} segundos.")
            logging.info(f"UsuÃ¡rio '{self.username}' configurou atraso forÃ§ado para {delay} segundos.")
        except ValueError:
            print("Valor invÃ¡lido. Digite um nÃºmero inteiro.")


def show_menu():
    """
    Exibe o menu principal de opÃ§Ãµes da aplicaÃ§Ã£o de usuÃ¡rio.
    """
    print("\n===== Menu da Rede Social =====")
    print("1. Publicar texto")
    print("2. Seguir usuÃ¡rio")
    print("3. Enviar mensagem privada")
    print("4. Ver notificaÃ§Ãµes")
    print("5. Ver timeline")
    print("6. ForÃ§ar atraso no relÃ³gio")
    print("7. Sair")


def main_menu():
    """
    Loop principal do cliente. Cria usuÃ¡rio e despacha para cada funcionalidade via menu.
    """
    usernameInput = input("Digite seu nome de usuÃ¡rio: ")
    user = User(usernameInput)

    while True:
        show_menu()
        try:
            option = int(input("Escolha uma opÃ§Ã£o: "))
        except ValueError:
            print("Por favor, digite um nÃºmero vÃ¡lido.")
            continue

        if option == 1:
            user.post_text()
        elif option == 2:
            user.follow_user()
        elif option == 3:
            user.send_private_message()
        elif option == 4:
            user.view_notifications()
        elif option == 5:
            user.view_timeline()
        elif option == 6:
            user.set_forced_delay()
        elif option == 7:
            print("Saindo...")
            break
        else:
            print("OpÃ§Ã£o invÃ¡lida. Tente novamente.")


if __name__ == "__main__":
    main_menu()
